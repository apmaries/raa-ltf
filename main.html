<!DOCTYPE html>
<html>
  <head>
    <title>RAA LTF</title>

    <link
      href="https://dhqbrvplips7x.cloudfront.net/common-ui-docs/genesys-webcomponents/3.8.1-178/genesys-webcomponents/genesys-webcomponents.css"
      rel="stylesheet"
    />

    <script
      type="module"
      src="https://dhqbrvplips7x.cloudfront.net/common-ui-docs/genesys-webcomponents/3.8.1-178/genesys-webcomponents/genesys-webcomponents.esm.js"
    ></script>
    <script src="https://sdk-cdn.mypurecloud.com/javascript/latest/purecloud-platform-client-v2.min.js"></script>

    <style>
      body {
        background-color: antiquewhite;
      }

      gux-tab-panel > div {
        width: 1700px;
        padding: 20px;
      }

      gux-tab-panel > div > div {
        margin-bottom: 20px;
      }

      gux-button {
        width: 100px;
      }

      gux-table-beta table th {
        padding-right: 12px;
      }

      fieldset {
        background-color: white;
        width: 80%;
        margin: 0 auto;
      }

      #forecasts-table td {
        text-align: left;
      }

      #forecasts-table th,
      #forecasts-table td {
        text-align: left;
      }

      .buttons-div {
        display: flex;
        justify-content: space-between;
      }

      .sgt-value {
        font-weight: bold;
      }

      .forecast-input-field {
        width: 80px;
      }

      .flex-container {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
    </style>
  </head>
  <body>
    <fieldset>
      <h1>RAA Long Term Forecast</h1>

      <gux-tabs orientation="vertical" style="display: block">
        <gux-tab-list id="tab-list" slot="tab-list">
          <gux-tab id="inputs-tab" tab-id="1">Inputs</gux-tab>
          <gux-tab id="outputs-tab" tab-id="2">Outputs</gux-tab>
        </gux-tab-list>
        <gux-tab-panel id="inputs-tab-panel" tab-id="1" style="overflow: auto">
          <div class="dropdown-div">
            <label for="business-unit"
              ><h2 id="bu-header">Business Unit:</h2></label
            >
            <gux-dropdown
              id="business-unit"
              filter-type="starts-with"
              placeholder="Select a Business Unit"
            >
              <gux-listbox
                id="business-unit-listbox"
                aria-label="Business Unit Selection"
              >
                <!-- BU objects will be added dynamically -->
              </gux-listbox>
            </gux-dropdown>
          </div>

          <div class="table-div">
            <label for="forecast"><h2 id="fc-header">Forecast:</h2></label>

            <gux-table-beta id="forecasts-table" object-table>
              <table slot="data">
                <thead>
                  <tr>
                    <th data-column-name="radio" data-cell-action>Select</th>
                    <th data-column-name="week-date">Week Date</th>
                    <th data-column-name="week-count">Week Count</th>
                    <th data-column-name="week-description">Description</th>
                  </tr>
                </thead>
                <tbody id="forecasts-table-body">
                  <!-- Forecast objects will be added dynamically -->
                </tbody>
              </table>
            </gux-table-beta>
          </div>

          <div class="buttons-div">
            <gux-button id="generate-button" accent="primary" disabled
              >Generate</gux-button
            >
          </div>
        </gux-tab-panel>
        <gux-tab-panel id="outputs-tab-panel" tab-id="2" style="overflow: auto">
          <div class="dropdown-div">
            <label for="planning-group"><h2>Planning Group:</h2></label>
            <gux-dropdown
              id="planning-group"
              filter-type="starts-with"
              placeholder="Select a Planning Group to continue..."
            >
              <gux-listbox
                id="planning-group-listbox"
                aria-label="Planning Group Selection"
              >
                <!-- PG objects will be added dynamically -->
              </gux-listbox>
            </gux-dropdown>
            <div id="pg-service-goals">
              <h3>Service Goals:</h3>
              <p>
                Service Level: <span id="sgt-gos" class="sgt-value"></span>
                <br />
                Average Speed of Answer:
                <span id="sgt-asa" class="sgt-value"></span><br />
                Abandonment Rate:
                <span id="sgt-abn" class="sgt-value"></span>
              </p>
            </div>
          </div>
          <div class="table-div">
            <label for="forecast"><h2>Outputs:</h2></label>
            <div id="disclaimer">
              <p style="color: red">
                <gux-icon icon-name="warning" decorative="true"></gux-icon>
                Staffing & performance forecasts will differ from what is
                calculated later by GC WFM
              </p>
            </div>

            <gux-table-beta id="outputs-table" object-table>
              <table slot="data">
                <thead>
                  <tr>
                    <!-- Month of the forecast -->
                    <th data-column-name="cal-month" id="monthColumn">
                      <div class="flex-container">
                        <div>Month</div>
                        <div>
                          <gux-icon
                            icon-name="help"
                            screenreader-text="help-icon"
                          ></gux-icon
                          ><gux-tooltip>Calendar month "YYYY-MM"</gux-tooltip>
                        </div>
                      </div>
                    </th>

                    <!-- Forecasted number of calls offered -->
                    <th data-column-name="offered" id="forecastOfferedColumn">
                      <div class="flex-container">
                        <div>Forecast Offered</div>
                        <div>
                          <gux-icon
                            icon-name="help"
                            screenreader-text="help-icon"
                          ></gux-icon
                          ><gux-tooltip
                            >Forecast aggregate offered volume</gux-tooltip
                          >
                        </div>
                      </div>
                    </th>

                    <!-- Forecasted Average Handling Time -->
                    <th data-column-name="aht" id="forecastAhtColumn">
                      <div class="flex-container">
                        <div>Forecast AHT</div>
                        <div>
                          <gux-icon
                            icon-name="help"
                            screenreader-text="help-icon"
                          ></gux-icon
                          ><gux-tooltip>Forecasted weighted AHT</gux-tooltip>
                        </div>
                      </div>
                    </th>

                    <!-- Base Full-Time Equivalent -->
                    <th data-column-name="base-fte" id="baseFteColumn">
                      <div class="flex-container">
                        <div>Base FTE</div>
                        <div>
                          <gux-icon
                            icon-name="help"
                            screenreader-text="help-icon"
                          ></gux-icon
                          ><gux-tooltip
                            >Base Full-Time Equivalent - calculated by Erlang
                            'Agents' formula</gux-tooltip
                          >
                        </div>
                      </div>
                    </th>

                    <!-- Mean Square Error of Forecast -->
                    <th data-column-name="mseff" id="mseffColumn">
                      <div class="flex-container">
                        <div>MSEFF</div>
                        <div>
                          <gux-icon
                            icon-name="help"
                            screenreader-text="help-icon"
                          ></gux-icon
                          ><gux-tooltip
                            >Multi-skilled efficiency? Need to confirm what (if
                            anything should happen with this)</gux-tooltip
                          >
                        </div>
                      </div>
                    </th>

                    <!-- Shrinkage percentage -->
                    <th data-column-name="shrinkage" id="shrinkageColumn">
                      <div class="flex-container">
                        <div>Shrinkage</div>
                        <div>
                          <gux-icon
                            icon-name="help"
                            screenreader-text="help-icon"
                          ></gux-icon
                          ><gux-tooltip
                            >Shrinkage percentage - default value could be
                            hardcoded, supplied as user variable on Inputs tab
                            or possibly taken from GC (Default shrinkage per
                            MU)</gux-tooltip
                          >
                        </div>
                      </div>
                    </th>

                    <!-- Required Full-Time Equivalent -->
                    <th data-column-name="req-fte" id="reqFteColumn">
                      <div class="flex-container">
                        <div>Req FTE</div>
                        <div>
                          <gux-icon
                            icon-name="help"
                            screenreader-text="help-icon"
                          ></gux-icon
                          ><gux-tooltip
                            >Required Full-Time Equivalent - calculated as Base
                            FTE + Shrinkage</gux-tooltip
                          >
                        </div>
                      </div>
                    </th>

                    <!-- Actual Full-Time Equivalent - can be taken from GC -->
                    <th data-column-name="act-fte" id="actFteColumn">
                      <div class="flex-container">
                        <div>Act FTE</div>
                        <div>
                          <gux-icon
                            icon-name="help"
                            screenreader-text="help-icon"
                          ></gux-icon
                          ><gux-tooltip
                            >Actual Full-Time Equivalent - can be taken from GC
                            to start (need to look up all agents PG memberships
                            through queues / skills / languages). Dynamically
                            updated after adjustments</gux-tooltip
                          >
                        </div>
                      </div>
                    </th>

                    <!-- Predicted Service Level % with Actual Full-Time Equivalents -->
                    <th
                      data-column-name="sl-pred"
                      id="slPercentPredictedColumn"
                    >
                      <div class="flex-container">
                        <div>Predicted SL%</div>
                        <div>
                          <gux-icon
                            icon-name="help"
                            screenreader-text="help-icon"
                          ></gux-icon
                          ><gux-tooltip
                            >Predicted Service Level % with Actual Full-Time
                            Equivalents - calculated by Erlang 'SLA'
                            formula</gux-tooltip
                          >
                        </div>
                      </div>
                    </th>

                    <!-- Attrition percentage -->
                    <th data-column-name="attr-per" id="attritionPercentColumn">
                      <div class="flex-container">
                        <div>Attrition %</div>
                        <div>
                          <gux-icon
                            icon-name="help"
                            screenreader-text="help-icon"
                          ></gux-icon
                          ><gux-tooltip
                            >Attrition percentage - dynamically updates from
                            changes in Absolute Attrition and updates FTE
                            Adjusted, FTE Difference, Adjusted SL% and future
                            months Actual FTE</gux-tooltip
                          >
                        </div>
                      </div>
                    </th>

                    <!-- Absolute Attrition -->
                    <th data-column-name="attr-per" id="absAttritionColumn">
                      <div class="flex-container">
                        <div>ABS Attrition</div>
                        <div>
                          <gux-icon
                            icon-name="help"
                            screenreader-text="help-icon"
                          ></gux-icon
                          ><gux-tooltip
                            >Absolute attrition - dynamically updates from
                            changes in Attrition % and updates FTE Adjusted, FTE
                            Difference, Adjusted SL% and future months Actual
                            FTE</gux-tooltip
                          >
                        </div>
                      </div>
                    </th>

                    <!-- New Hire Full-Time Equivalent -->
                    <th data-column-name="new-fte" id="newHireFteColumn">
                      <div class="flex-container">
                        <div>New Hire FTE</div>
                        <div>
                          <gux-icon
                            icon-name="help"
                            screenreader-text="help-icon"
                          ></gux-icon
                          ><gux-tooltip
                            >New Hire Full-Time Equivalent - dynamically updates
                            FTE Adjusted, FTE Difference, Adjusted SL% and
                            future months Actual FTE</gux-tooltip
                          >
                        </div>
                      </div>
                    </th>

                    <!-- Adjusted Full-Time Equivalents (Current - Attrition + New) -->
                    <th data-column-name="variance" id="fteAdjustedColumn">
                      <div class="flex-container">
                        <div>FTE Adjusted</div>
                        <div>
                          <gux-icon
                            icon-name="help"
                            screenreader-text="help-icon"
                          ></gux-icon
                          ><gux-tooltip
                            >Adjusted Full-Time Equivalents (Current - Attrition
                            + New)</gux-tooltip
                          >
                        </div>
                      </div>
                    </th>

                    <!-- Variance in Required Full-Time Equivalent -->
                    <th data-column-name="variance" id="fteReqDifference">
                      <div class="flex-container">
                        <div>FTE Difference</div>
                        <div>
                          <gux-icon
                            icon-name="help"
                            screenreader-text="help-icon"
                          ></gux-icon
                          ><gux-tooltip
                            >Variance in FTE - calculated as Required -
                            Actual</gux-tooltip
                          >
                        </div>
                      </div>
                    </th>

                    <!-- Projected Service Level % with Adjusted Full-Time Equivalents -->
                    <th data-column-name="sl-adj" id="slPercentAdjustedColumn">
                      <div class="flex-container">
                        <div>Adjusted SL%</div>
                        <div>
                          <gux-icon
                            icon-name="help"
                            screenreader-text="help-icon"
                          ></gux-icon
                          ><gux-tooltip
                            >Projected Service Level % with Adjusted Full-Time
                            Equivalents - calculated by Erlang 'SLA'
                            formula</gux-tooltip
                          >
                        </div>
                      </div>
                    </th>
                  </tr>
                </thead>
                <tbody id="outputs-table-body">
                  <!-- Forecast objects will be added dynamically -->
                </tbody>
              </table>
            </gux-table-beta>
          </div>
          <div class="buttons-div">
            <gux-button id="back-button" accent="secondary">Back</gux-button>
            <gux-button id="export-button" accent="primary">Export</gux-button>
          </div>
        </gux-tab-panel>
      </gux-tabs>
    </fieldset>

    <!-- Load the PureCloud platform client library -->
    <script src="https://sdk-cdn.mypurecloud.com/javascript/latest/purecloud-platform-client-v2.min.js"></script>

    <!-- Load the calculator script -->
    <script type="module" src="/raa-ltf/src/calculator.js"></script>

    <!-- Load the erlang module -->
    <script type="module" src="/raa-ltf/src/erlangXL97.js"></script>

    <!-- Script to login with Cloud -->
    <script>
      (async function () {
        // Check testing mode by protocol. If https then production, else testing
        window.isTesting = window.location.protocol !== "https:";

        if (window.isTesting) {
          console.log("[LTF] Testing mode");
        } else {
          console.log("[LTF] Production mode");

          var platformClient = window.require("platformClient");

          var clientId = "4c89c35c-d1ec-4fad-91f5-240d37b4d546";

          window.client = platformClient.ApiClient.instance;
          client.setEnvironment("usw2.pure.cloud");
          client.setPersistSettings(true, "raa-ltf");

          try {
            await client.loginImplicitGrant(
              clientId,
              "https://apmaries.github.io/raa-ltf/main.html"
            );
          } catch (e) {
            console.error("[LTF] Error logging in", e);
          }
        }
      })();
    </script>

    <!-- Script to do stuff -->
    <script type="module">
      import { aggregate } from "/raa-ltf/src/calculator.js";
      import { agents, sla } from "/raa-ltf/src/erlangXL97.js";

      // Declare global scope variables
      let selectedBuId;
      let selectedBuName;
      let selectedForecastId;
      let selectedForecastWeekDate;
      let selectedPgId;
      let selectedPgName;
      let forecastData;
      let serviceLevelPercent;
      let serviceLevelSeconds;
      let averageSpeedOfAnswerSeconds;
      let abandonmentRatePercent;
      let outputsTableBody = document.getElementById("outputs-table-body");

      // Check testing mode by protocol. If https then production, else testing
      // const isTesting = window.location.protocol !== "https:";

      window.onerror = function (message, source, lineno, colno, error) {
        console.error(
          `[LTF] An error occurred: ${message}\nAt: ${source}:${lineno}:${colno}`
        );
        console.error(error);
        return true; // Prevents the firing of the default event handler.
      };

      document.addEventListener("DOMContentLoaded", async function () {
        var platformClient = window.require("platformClient");
        const client = window.client;
        const wfmApi = new platformClient.WorkforceManagementApi();

        const buListbox = document.getElementById("business-unit-listbox");
        //const forecastListbox = document.getElementById("forecast-listbox");
        const tableBody = document.getElementById("forecasts-table-body");

        // Functions start here

        // Function to populate dropdowns
        function populateDropdown(listboxId, data, emptyMessage) {
          const listbox = document.getElementById(listboxId);
          // Clear existing options
          listbox.innerHTML = "";

          // If no data found, display message in dropdown
          if (data.length === 0) {
            console.log(`[LTF] ${emptyMessage}`);
            const option = document.createElement("gux-option");
            option.innerHTML = emptyMessage;
            listbox.appendChild(option);
            return;
          }

          // sort data by name (not case sensitive)
          data.sort((a, b) =>
            a.name.localeCompare(b.name, undefined, { sensitivity: "base" })
          );

          // Populate dropdown
          const fragment = document.createDocumentFragment();
          data.forEach((item) => {
            const option = document.createElement("gux-option");
            option.value = item.id;

            // Remove <!----> if found in item.name
            item.name = item.name.replace(/<!---->/g, "");

            option.name = item.name;
            option.innerHTML = item.name;

            // Add serviceGoalTemplate as a data attribute if it exists
            if (item.serviceGoalTemplate) {
              option.dataset.serviceGoalTemplate = JSON.stringify(
                item.serviceGoalTemplate
              );
            }
            fragment.appendChild(option);
          });
          listbox.appendChild(fragment);
        }

        // Function to get Business Units
        async function getBusinessUnits() {
          try {
            let data;
            if (window.isTesting) {
              const response = await fetch(".test/businessUnits.json");
              data = await response.json();
            } else {
              data = await wfmApi.getWorkforcemanagementBusinessunits();
            }
            console.log("[LTF] Business Units = ", data);
            return data.entities || [];
          } catch (err) {
            console.error("[LTF] Error getting business units", err);
            return [];
          }
        }

        // Function to get Forecasts
        async function getForecasts(selectedBuId) {
          try {
            let data;
            if (window.isTesting) {
              const response = await fetch(".test/forecasts.json");
              data = await response.json();
            } else {
              data =
                await wfmApi.getWorkforcemanagementBusinessunitWeekShorttermforecasts(
                  selectedBuId,
                  "recent"
                );
            }
            console.log("[LTF] Forecasts = ", data);

            // filter results to only include forecasts with weekCount > 6
            data.entities = data.entities.filter((item) => item.weekCount > 6);

            return data.entities || [];
          } catch (err) {
            console.error("[LTF] Error getting forecasts", err);
            return [];
          }
        }

        // Function to initialize the
        async function initInputsTab() {
          // Get business unit entities
          const businessUnits = await getBusinessUnits();

          // Populate business unit dropdown
          populateDropdown(
            "business-unit-listbox",
            businessUnits,
            "No business units found"
          );
        }

        // Function to generate forecast output
        async function initOutputsTab() {
          // Function to get forecast Planning Groups
          async function getForecastPlanningGroups() {
            try {
              let data;
              if (window.isTesting) {
                const response = await fetch(
                  ".test/forecastPlanningGroups.json"
                );
                data = await response.json();
              } else {
                data =
                  await wfmApi.getWorkforcemanagementBusinessunitWeekShorttermforecastPlanninggroups(
                    selectedBuId,
                    selectedForecastWeekDate,
                    selectedForecastId
                  );
              }
              console.log("[LTF] Forecast Planning Groups = ", data);
              return data.entities || [];
            } catch (err) {
              console.error(
                "[LTF] Error getting forecast planning groups",
                err
              );
              return [];
            }
          }

          // Function to get forecast data
          async function getForecastData() {
            try {
              let data;
              if (window.isTesting) {
                const response = await fetch(".test/forecastData.json");
                data = await response.json();
              } else {
                data =
                  await wfmApi.getWorkforcemanagementBusinessunitWeekShorttermforecastLongtermforecastdata(
                    selectedBuId,
                    selectedForecastWeekDate,
                    selectedForecastId
                  );
              }
              const result = data.result.planningGroups || [];
              console.log("[LTF] Forecast data returned", result);
              return result;
            } catch (err) {
              console.error("[LTF] Error getting forecast data", err);
              return [];
            }
          }

          // Main generate code
          // Get forecast table selected object by forecast-radio name
          const selectedForecastRadio = document.querySelector(
            "input[name='forecast-radio']:checked"
          );

          console.log("[LTF] Generating LTF");
          console.log("[LTF] Selected business unit: ", selectedBuId);
          console.log("[LTF] Selected forecast: ", selectedForecastId);
          console.log("[LTF] Selected week date: ", selectedForecastWeekDate);

          // Switch to tab 2
          document.querySelector("#outputs-tab").click();

          // Get forecast planning groups
          const forecastPlanningGroups = await getForecastPlanningGroups();

          // Populate forecast planning group dropdown
          populateDropdown(
            "planning-group-listbox",
            forecastPlanningGroups,
            "No forecast planning groups found"
          );

          const forecastData = await getForecastData();

          return forecastData;
        }

        // Functions end here

        // init on page load
        await initInputsTab();

        // Event listeners
        // Event listener for bu-listbox
        buListbox.addEventListener("change", async (event) => {
          selectedBuId = event.target.value;

          // Get the selected gux-option's innerHTML
          var selectedOption = Array.from(
            buListbox.querySelectorAll("gux-option")
          ).find((option) => option.value === selectedBuId);
          selectedBuName = selectedOption ? selectedOption.innerHTML : "";

          // Remove <!----> if found in selectedBuName
          selectedBuName = selectedBuName.replace(/<!---->/g, "");

          console.log(
            `[LTF] User selects business unit: ${selectedBuId} (${selectedBuName})`
          );

          // Remove existing forecast options
          tableBody.innerHTML = "";

          // Get long term forecast objects to populate dropdown
          // Forecast entities are filtered to only include forecasts with weekCount > 6
          const forecasts = await getForecasts(selectedBuId);

          // If no forecasts found, add table row with message
          if (forecasts.length === 0) {
            console.log("[LTF] No forecasts found");
            const row = document.createElement("tr");
            row.innerHTML = `<td colspan="4">No forecasts found</td>`;
            tableBody.appendChild(row);
            return;
          }

          // sort data by weekDate (not case sensitive)
          forecasts.sort((a, b) =>
            a.weekDate.localeCompare(b.weekDate, undefined, {
              sensitivity: "base",
            })
          );

          // Populate forecasts table

          const fragment = document.createDocumentFragment();
          forecasts.forEach((item) => {
            const row = document.createElement("tr");
            // Add a radio button to the first cell of each row where forecastId is the value and weekDate is data-week-date attribute
            row.innerHTML = `
                <td><input type="radio" name="forecast-radio" value="${item.id}" data-week-date="${item.weekDate}"></td>
                <td>${item.weekDate}</td>
                <td>${item.weekCount}</td>
                <td>${item.description}</td>
              `;
            fragment.appendChild(row);
          });
          tableBody.appendChild(fragment);

          // Event listener for the forecast-radios
          const forecastRadios = document.querySelectorAll(
            "input[name='forecast-radio']"
          );
          forecastRadios.forEach((radio) => {
            radio.addEventListener("change", (event) => {
              selectedForecastId = event.target.value;
              selectedForecastWeekDate = event.target.dataset.weekDate;

              console.log(
                `[LTF] User selects forecast: ${selectedForecastWeekDate} - ${selectedForecastId} (${selectedBuName})`
              );

              // Enable generate-button
              document
                .getElementById("generate-button")
                .removeAttribute("disabled");
            });
          });
        });

        // Event listener for generate-button
        document
          .getElementById("generate-button")
          .addEventListener("click", async () => {
            forecastData = await initOutputsTab(
              selectedBuId,
              selectedForecastId
            );
          });

        // Event listener for back button
        document.getElementById("back-button").addEventListener("click", () => {
          // Switch to tab 1
          console.log("[LTF] Switching to tab 1");
          document.querySelector("#inputs-tab").click();
        });

        // Event listener for planning-group-listbox
        const pgListbox = document.getElementById("planning-group-listbox");
        pgListbox.addEventListener("change", async (event) => {
          selectedPgId = event.target.value;

          // Get the selected gux-option's innerHTML
          var selectedOption = Array.from(
            pgListbox.querySelectorAll("gux-option")
          ).find((option) => option.value === selectedPgId);
          selectedPgName = selectedOption ? selectedOption.innerHTML : "";

          // Remove <!----> if found in planningGroupName
          selectedPgName = selectedPgName.replace(/<!---->/g, "");

          console.log(
            `[LTF] User selects planning group: ${selectedPgId} (${selectedPgName})`
          );

          // Get service goals
          const serviceGoalTemplate = JSON.parse(
            selectedOption.dataset.serviceGoalTemplate
          );
          console.log("[LTF] Service Goal Template = ", serviceGoalTemplate);

          // Clear previous service goals
          document.getElementById("sgt-gos").innerHTML = "n/a";
          document.getElementById("sgt-asa").innerHTML = "n/a";
          document.getElementById("sgt-abn").innerHTML = "n/a";

          // Populate service goals
          // Check if serviceGoalTemplate has serviceLevel property
          if (serviceGoalTemplate.serviceLevel) {
            serviceLevelPercent = serviceGoalTemplate.serviceLevel.percent;
            serviceLevelSeconds = serviceGoalTemplate.serviceLevel.seconds;

            document.getElementById(
              "sgt-gos"
            ).innerHTML = `${serviceLevelPercent}% in ${serviceLevelSeconds} seconds`;
          }

          // Check if serviceGoalTemplate has averageSpeedOfAnswer property
          if (serviceGoalTemplate.averageSpeedOfAnswer) {
            averageSpeedOfAnswerSeconds =
              serviceGoalTemplate.averageSpeedOfAnswer.seconds;
            document.getElementById(
              "sgt-asa"
            ).innerHTML = `${averageSpeedOfAnswerSeconds} seconds`;
          }

          // Check if serviceGoalTemplate has abandonmentRate property
          if (serviceGoalTemplate.abandonRate) {
            abandonmentRatePercent = serviceGoalTemplate.abandonRate.percent;
            document.getElementById(
              "sgt-abn"
            ).innerHTML = `${abandonmentRatePercent}%`;
          }

          console.log("[LTF] Forecast data = ", forecastData);

          // Remove existing output table rows

          outputsTableBody.innerHTML = "";

          // Generate some random numbers for the demo
          const randOffered =
            Math.floor(Math.random() * (70000 - 76000 + 1)) + 70000;
          const randAvgOfferedPerDay =
            Math.floor(Math.random() * (600 - 650 + 1)) + 600;
          const randAht = Math.floor(Math.random() * (240 - 260 + 1)) + 240;

          // DEMO DATA
          const demoData = [
            {
              month: "2024-01",
              offered: 72673,
              avgOfferedPerDay: 606,
              aht: 242,
            },
            {
              month: "2024-02",
              offered: 70152,
              avgOfferedPerDay: 621,
              aht: 247,
            },
            {
              month: "2024-03",
              offered: 73079,
              avgOfferedPerDay: 619,
              aht: 256,
            },
            {
              month: "2024-04",
              offered: randOffered,
              avgOfferedPerDay: randAvgOfferedPerDay,
              aht: randAht,
            },
          ];

          // Populate outputs table
          const fragment = document.createDocumentFragment();
          const rowsPromises = demoData.map(async (item) => {
            // Convert service level percent to a decimal
            const serviceLevelPercentDecimal = serviceLevelPercent / 100;

            // Calculate the base FTE
            const baseFte = await agents(
              serviceLevelPercentDecimal,
              serviceLevelSeconds,
              item.avgOfferedPerDay,
              item.aht
            );
            console.log(
              `[LTF] ${item.month} =Agents(${serviceLevelPercentDecimal}, ${serviceLevelSeconds}, ${item.avgOfferedPerDay}, ${item.aht}) = ${baseFte}`
            );

            // Default shrinkage value
            const shrinkage = 0.0;

            // Calculate the required FTE to 2 decimal places
            const requiredFte = (baseFte * (1 + shrinkage)).toFixed(1);

            // Calculate the actual FTE
            // This can be done as input or taken from GC... though need to look at each agent route paths. Will also be headcount.
            const actualFte = 49.0;

            // Initial calculate of predicted service level % using (current fte - shrinkage)
            const predictedServiceLevel = await sla(
              actualFte * (1 - shrinkage),
              serviceLevelSeconds,
              item.avgOfferedPerDay,
              item.aht
            );
            console.log(
              `[LTF] ${item.month} =SLA(${baseFte}, ${serviceLevelSeconds}, ${item.avgOfferedPerDay}, ${item.aht}) = ${predictedServiceLevel}`
            );

            // Convert predictedServiceLevel to a percentage with 1 decimal place
            const predictedServiceLevelPercentage = (
              predictedServiceLevel * 100
            ).toFixed(1);

            // Initial calculate of FTE Adjusted
            const fteAdjusted = actualFte.toFixed(1);

            // Initial calculate of FTE Difference
            const fteDifference = (fteAdjusted - requiredFte).toFixed(1);

            const row = document.createElement("tr");
            row.innerHTML = `
              <td id="${selectedPgId}_month">${item.month}</td>
              <td id="${selectedPgId}_offered_${item.month}" data-avg-offered-per-day="${item.avgOfferedPerDay}">${item.offered}</td>
              <td id="${selectedPgId}_aht_${item.month}">${item.aht}</td>
              <td id="${selectedPgId}_fteBase_${item.month}">${baseFte}</td>
              <td id="${selectedPgId}_mseff-${item.month}">1</td>
              <td id="${selectedPgId}_shrinkage_${item.month}"><input type="number" id="${selectedPgId}_${item.month}_shrPercentInput" class="forecast-input-field" min="0" max="100" step="1" value=${shrinkage} /></td>
              <td id="${selectedPgId}_fteReq_${item.month}">${requiredFte}</td>
              <td id="${selectedPgId}_fteAct_${item.month}">${actualFte}</td>
              <td id="${selectedPgId}_slaPred_${item.month}">${predictedServiceLevelPercentage}%</td>
              <td id="${selectedPgId}_attrPercent_${item.month}"><input type="number" id="${selectedPgId}_${item.month}_attrPercentInput" class="forecast-input-field" min="0" max="100" step="1" value="0.0" /></td>
              <td id="${selectedPgId}_attrAbs_${item.month}"><input type="number" id="${selectedPgId}_${item.month}_attrAbsoluteInput" class="forecast-input-field" min="0" max="100" step="1" value="0.0" /></td>
              <td id="${selectedPgId}_fteNew_${item.month}"><input type="number" id="${selectedPgId}_${item.month}_newFteInput" class="forecast-input-field" min="0" max="100" step="1" value="0" /></td>
              <td id="${selectedPgId}_fteAdj_${item.month}">${fteAdjusted}</td>
              <td id="${selectedPgId}_fteDiff_${item.month}">${fteDifference}</td>
              <td id="${selectedPgId}_slaAdj_${item.month}">${predictedServiceLevelPercentage}%</td>
            `;
            return row;
          });

          Promise.all(rowsPromises).then((rows) => {
            rows.forEach((row) => fragment.appendChild(row));
            outputsTableBody.appendChild(fragment);
          });
        });

        // Attach an event listener to the table body
        outputsTableBody.addEventListener("input", async function (event) {
          function updateActFTE(currentMonth, newBaseFTE) {
            // Get all the rows of the table
            const rows = outputsTableBody.querySelectorAll("tr");

            // Iterate over the rows
            rows.forEach((row) => {
              // Get the month of the row
              const rowMonth = row.querySelector("td:first-child").textContent;

              // If the row month is greater than the current month, update the base FTE
              if (rowMonth > currentMonth) {
                const actFteCell = row.querySelector(
                  `td[id$="_fteAct_${rowMonth}"]`
                );
                actFteCell.textContent = newBaseFTE;

                // Update the FTE Adjusted column
                const adjFteCell = row.querySelector(
                  `td[id$="_fteAdj_${rowMonth}"]`
                );
                adjFteCell.textContent = newBaseFTE;

                // Recalculate the FTE Difference column
                const reqFteCell = row.querySelector(
                  `td[id$="_fteReq_${rowMonth}"]`
                );
                const diffFteCell = row.querySelector(
                  `td[id$="_fteDiff_${rowMonth}"]`
                );
                diffFteCell.textContent = (
                  parseFloat(newBaseFTE) - parseFloat(reqFteCell.textContent)
                ).toFixed(1);
              }
            });
          }

          // Get the current month from the input id
          const currentMonth = event.target.id.split("_")[1];

          // Get the current shrinkage value
          const shrinkage = parseFloat(event.target.value) / 100;
          console.warn("shrinkage = ", shrinkage);

          // Get the curent offered and aht values for updating SL%
          const avgOfferedPerDay = document.getElementById(
            `${selectedPgId}_offered_${currentMonth}`
          ).dataset.avgOfferedPerDay;
          const aht = document.getElementById(
            `${selectedPgId}_aht_${currentMonth}`
          ).textContent;

          // Get the current FTE value - used for SL% and Adjusted FTE calculations
          const fteCurrent = document.getElementById(
            `${selectedPgId}_fteAct_${currentMonth}`
          ).textContent;

          // Get the adjusted FTE element and value
          const fteAdjustedEle = document.getElementById(
            `${selectedPgId}_fteAdj_${currentMonth}`
          );
          const currentFteAdjusted = parseFloat(fteAdjustedEle.textContent);

          // Get the FTE Difference element and value
          const fteDifferenceEle = document.getElementById(
            `${selectedPgId}_fteDiff_${currentMonth}`
          );
          const fteDifference = parseFloat(fteDifferenceEle.textContent);

          // Get the adjusted SL% element
          const adjSlaEle = document.getElementById(
            `${selectedPgId}_slaAdj_${currentMonth}`
          );

          // Temp logging
          console.warn("event = ", event);
          console.warn("event.target.id = ", event.target.id);
          console.warn("currentMonth = ", currentMonth);
          console.warn("selectedPgId = ", selectedPgId);
          console.warn("shrinkage = ", shrinkage);
          console.warn("fteCurrent = ", fteCurrent);
          console.warn("fteDifference = ", fteDifference);

          // Check if the event target is a shrinkage input
          if (event.target.id.endsWith("_shrPercentInput")) {
            // Get the current base FTE value
            const baseFte = parseFloat(
              document.getElementById(`${selectedPgId}_fteBase_${currentMonth}`)
                .textContent
            );

            // Calculate the new required FTE value
            const updatedReqFte = baseFte * (1 + shrinkage);

            // Calculate the new predicted service level value
            const predictedServiceLevel = await sla(
              fteCurrent * (1 - shrinkage),
              serviceLevelSeconds,
              avgOfferedPerDay,
              aht
            );
            console.log(
              `[LTF] ${currentMonth} predicted =SLA(${
                fteCurrent * (1 - shrinkage)
              }, ${serviceLevelSeconds}, ${avgOfferedPerDay}, ${aht}) = ${predictedServiceLevel}`
            );

            // Update the required FTE cell with the new value
            document.getElementById(
              `${selectedPgId}_fteReq_${currentMonth}`
            ).textContent = updatedReqFte.toFixed(1);

            // Update the predicted service level cell with the new value
            document.getElementById(
              `${selectedPgId}_slaPred_${currentMonth}`
            ).textContent = `${(predictedServiceLevel * 100).toFixed(1)}%`;

            // Calculate the new FTE Difference value
            fteDifferenceEle.textContent = (fteCurrent - updatedReqFte).toFixed(
              2
            );

            // Calculate the adjusted service level value
            const adjustedServiceLevel = await sla(
              currentFteAdjusted * (1 - shrinkage),
              serviceLevelSeconds,
              avgOfferedPerDay,
              aht
            );
            console.log(
              `[LTF] ${currentMonth} adjusted =SLA(${
                currentFteAdjusted * (1 - shrinkage)
              }, ${serviceLevelSeconds}, ${avgOfferedPerDay}, ${aht}) = ${adjustedServiceLevel}`
            );

            // Update the adjusted service level cell with the new value
            adjSlaEle.textContent = `${(adjustedServiceLevel * 100).toFixed(
              1
            )}%`;
          }

          // Check if the event target is attrition %
          else if (event.target.id.endsWith("_attrPercentInput")) {
            // Get the current attrition % value
            const attritionPercent = parseFloat(event.target.value) / 100;

            // Get the current required FTE value
            const currentReqFte = parseFloat(
              document.getElementById(`${selectedPgId}_fteReq_${currentMonth}`)
                .textContent
            );

            // Calculate the absolute attrition value
            const absAttrition = fteCurrent * attritionPercent;

            // Update the absolute attrition input with the new value
            document.getElementById(
              `${selectedPgId}_${currentMonth}_attrAbsoluteInput`
            ).value = absAttrition.toFixed(1);

            // Calculate the new adjusted FTE value
            const updatedFteAdjusted = fteCurrent - absAttrition;

            // Update the adjusted FTE cell with the new value
            document.getElementById(
              `${selectedPgId}_fteAdj_${currentMonth}`
            ).textContent = updatedFteAdjusted.toFixed(1);

            // Call the function to update the base FTE for all subsequent months
            updateActFTE(currentMonth, updatedFteAdjusted.toFixed(1));

            // Calculate the new FTE Difference value and update the cell
            fteDifferenceEle.textContent = (
              updatedFteAdjusted - currentReqFte
            ).toFixed(1);

            // Calculate the adjusted service level value
            const adjustedServiceLevel = await sla(
              updatedFteAdjusted * (1 - shrinkage),
              serviceLevelSeconds,
              avgOfferedPerDay,
              aht
            );
            console.log(
              `[LTF] ${currentMonth} adjusted =SLA(${
                updatedFteAdjusted * (1 - shrinkage)
              }, ${serviceLevelSeconds}, ${avgOfferedPerDay}, ${aht}) = ${adjustedServiceLevel}`
            );

            // Update the adjusted service level cell with the new value
            adjSlaEle.textContent = `${(adjustedServiceLevel * 100).toFixed(
              1
            )}%`;
          }

          // Check if the event target is attrition abs
          else if (event.target.id.endsWith("_attrAbsoluteInput")) {
            // Get the current absolute attrition value
            const absAttrition = parseFloat(event.target.value);

            // Get the current required FTE value
            const currentReqFte = parseFloat(
              document.getElementById(`${selectedPgId}_fteReq_${currentMonth}`)
                .textContent
            );

            // Calculate the attrition % value
            const attritionPercent = absAttrition / fteCurrent;

            // Calculate the new adjusted FTE value
            const updatedFteAdjusted = fteCurrent - absAttrition;

            // Update the attrition % input with the new value
            document.getElementById(
              `${selectedPgId}_${currentMonth}_attrPercentInput`
            ).value = (attritionPercent * 100).toFixed(1);

            // Update the adjusted FTE cell with the new value
            document.getElementById(
              `${selectedPgId}_fteAdj_${currentMonth}`
            ).textContent = updatedFteAdjusted.toFixed(1);

            // Call the function to update the base FTE for all subsequent months
            updateActFTE(currentMonth, updatedFteAdjusted.toFixed(1));

            // Calculate the new FTE Difference value
            fteDifferenceEle.textContent = (
              updatedFteAdjusted - currentReqFte
            ).toFixed(1);

            // Calculate the adjusted service level value
            const adjustedServiceLevel = await sla(
              updatedFteAdjusted * (1 - shrinkage),
              serviceLevelSeconds,
              avgOfferedPerDay,
              aht
            );
            console.log(
              `[LTF] ${currentMonth} adjusted =SLA(${
                updatedFteAdjusted * (1 - shrinkage)
              }, ${serviceLevelSeconds}, ${avgOfferedPerDay}, ${aht}) = ${adjustedServiceLevel}`
            );

            // Update the adjusted service level cell with the new value
            adjSlaEle.textContent = `${(adjustedServiceLevel * 100).toFixed(
              1
            )}%`;
          }

          // Check if the event target is new hire
          else if (event.target.id.endsWith("_newFteInput")) {
            // Get the current new hire FTE value
            const newHireFte = parseFloat(event.target.value);

            // Calculate the new adjusted FTE value
            const updatedFteAdjusted =
              parseFloat(fteCurrent) + parseFloat(newHireFte);
            console.log(
              `[LTF] ${currentMonth} fteCurrent(${fteCurrent}) + newHireFte(${newHireFte}) = ${updatedFteAdjusted}`
            );

            // Update the adjusted FTE cell with the new value
            document.getElementById(
              `${selectedPgId}_fteAdj_${currentMonth}`
            ).textContent = updatedFteAdjusted.toFixed(1);

            // Call the function to update the base FTE for all subsequent months
            updateActFTE(currentMonth, updatedFteAdjusted.toFixed(1));

            // Calculate the new FTE Difference value
            fteDifferenceEle.textContent = (
              updatedFteAdjusted -
              parseFloat(
                document.getElementById(
                  `${selectedPgId}_fteReq_${currentMonth}`
                ).textContent
              )
            ).toFixed(1);

            // Calculate the adjusted service level value
            const adjustedServiceLevel = await sla(
              updatedFteAdjusted * (1 - shrinkage),
              serviceLevelSeconds,
              avgOfferedPerDay,
              aht
            );
            console.log(
              `[LTF] ${currentMonth} adjusted =SLA(${
                updatedFteAdjusted * (1 - shrinkage)
              }, ${serviceLevelSeconds}, ${avgOfferedPerDay}, ${aht}) = ${adjustedServiceLevel}`
            );

            // Update the adjusted service level cell with the new value
            adjSlaEle.textContent = `${(adjustedServiceLevel * 100).toFixed(
              1
            )}%`;
          }
        });

        // Event listener for export button
        document
          .getElementById("export-button")
          .addEventListener("click", () => {
            console.log("[LTF] Exporting data");
          });

        // TODO: Update export functionality
        // TODO: Probably move / update most of this stuff to a standalone JS file and refactor to improve readability
        // TODO: Probably need to force download service of forecast data to ensure a consistent response for small and large datasets
        // TODO: Add a loading spinner for the generate button
        // TODO: What if no service level in SGT?
        // TODO: Other service objectives?
        // TODO: Error handling?
      });
    </script>
  </body>
</html>
